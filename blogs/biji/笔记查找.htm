<!DOCTYPE HTML>
<html>

<head>
  <title>数据结构之查找</title>
  <link rel="shortcut icon" href="/jtahstu.github.com/images/favicon.ico" />
  <meta name="description" content="website description" />
  <meta name="keywords" content="website keywords, website keywords" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Tangerine&amp;v1" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz" />
  <link rel="stylesheet" type="text/css" href="style/style.css" />
</head>

<body>
  <div id="main">
    <div id="header">
      <div id="logo">
        <h1>jtahstu's blogs</h1>
        <div class="slogan">Here some notes!</div>
      </div>
      <div id="menubar">
        <ul id="menu">
          <!-- put class="current" in the li tag for the selected page - to highlight which page you're on -->
          <li><a href="../../index.html">Home</a></li>
					<li><a href="https://jtahstu.github.io/akoj.github.io/" target="_blank">OJ题解</a></li>
					<li><a href="../../classify/biji/index.html" target="_blank">笔记</a></li>
					<li><a href="../../classify/zongjie/index.html" target="_blank">总结</a></li>
					<li><a href="../../classify/wenzhang/index.html" target="_blank">文章</a></li>
		  <li><a href="../../aboute me/resume/index.html">About me</a></li>
        </ul>
      </div>
    </div>
    <div id="site_content">
      <div id="sidebar_container">
        <img class="paperclip" src="style/paperclip.png" alt="paperclip" /><img class="paperclip" src="style/paperclip.png" alt="paperclip" /><img class="paperclip" src="style/paperclip.png" alt="paperclip" />
        <div class="sidebar">
          <h3>数据结构查找</h3>
          <h5>2015/3/11</h5>
          <p>本文为数据结构中查找的笔记</p>
        </div>
      </div>	
    <div id="content">
        <!-- insert the page content here -->
      <h1>数据结构之查找</h1>
      <p>查找 <br>
本章重点： <br>
1、顺序表的查找 <br>
2、有序表的查找：折半查找法 <br>
3、二叉排序树及其查找过程（动态） <br>
4、二叉排序树的插入（动态） <br>
5、平衡二叉树、B-和B+树的结构 <br>
6、哈希表即哈希函数的构造方法了解 </p>
      <p>查找表： <br>
        静态查找表（查询） <br>
        动态查找表（查询、插入、删除  ） <br>
        主关键字  次关键字 </p>
      <p>平均查找长度：ASL=sum(Pi*Ci)<br>
        为提高ASL，需要人为增加数据元素的关系，以便按照某种规则查找。 </p>
      <p>&nbsp;&nbsp;&nbsp; 9.1 静态查找表 <br>
  &nbsp;&nbsp;&nbsp; 9.1.1顺序表的查找 <br>
        顺序表表示： <br>
        typedef&nbsp;int&nbsp;KeyType;&nbsp;&nbsp;<br>
        typedef&nbsp;struct&nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;KeyType&nbsp;key;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;InfoTypedata;&nbsp;&nbsp;<br>
        }NodeType;&nbsp;&nbsp;<br>
        typedef&nbsp;NodeType&nbsp;SeqList[MAXL]&nbsp;&nbsp;</p>
      <p>顺序查找 <br>
        int&nbsp;SeqSearch(SeqList&nbsp;R,&nbsp;int&nbsp;n,&nbsp;KeyType&nbsp;k)&nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&nbsp;&lt;n&nbsp;&amp;&amp;&nbsp;R[i].key&nbsp;!=&nbsp;k)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;=n)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i+&nbsp;1;&nbsp;&nbsp;<br>
      }&nbsp;&nbsp;</p>
      <p>&nbsp;&nbsp;&nbsp; 9.1.2有序表的查找 <br>
        1、折半查找 <br>
        int&nbsp;BinSearch(SeqList&nbsp;R,&nbsp;int&nbsp;n,&nbsp;KeyType&nbsp;k)&nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;low&nbsp;=&nbsp;0,high&nbsp;=&nbsp;n&nbsp;-&nbsp;1,&nbsp;mid;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(low&lt;=&nbsp;high)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=(low&nbsp;+&nbsp;high)&nbsp;/&nbsp;2;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(R[mid].key&nbsp;==&nbsp;k)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnmid&nbsp;+&nbsp;1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(R[mid].key&nbsp;&gt;&nbsp;k)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high=&nbsp;mid&nbsp;-&nbsp;1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=mid&nbsp;+&nbsp;1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;<br>
        }&nbsp;&nbsp;</p>
      <p>2、斐波那契查找：按照斐波那契数列分段查找 <br>
        3、插值查找：根据给定值key确定进行比较的关键字R[i].key的查找方法 <br>
  &nbsp;&nbsp;&nbsp; i=（key-R[i].key）/(R[h].key-R[l].key)*(h-l+1)<br>
  &nbsp;&nbsp;&nbsp; 适用于关键字均匀分布的表 </p>
      <p>&nbsp;&nbsp;&nbsp; 9.1.4索引顺序表的查找 <br>
        1、分块查找，索引顺序查找 <br>
        int&nbsp;IdxSearch(IDX&nbsp;I,int&nbsp;m,SeqList&nbsp;R,int&nbsp;n,KeyType&nbsp;k)&nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;intlow=0,high=m-1,mid,i;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;intb=n/m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//b为每块的记录个数&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;while(low&lt;=high)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在索引表中进行二分查找,找到的位置存放在low中&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid=(low+high)/2;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(I[mid].key&gt;=k)&nbsp;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high=mid-1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low=mid+1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;//应在索引表的high+1块中,再在线性表中进行顺序查找&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;i=I[high+1].link;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;while(i&lt;=I[high+1].link+b-1&nbsp;&amp;&amp;&nbsp;R[i].key!=k)&nbsp;i++;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;if(i&lt;=I[high+1].link+b-1)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return-1;&nbsp;&nbsp;<br>
        }&nbsp;&nbsp;<br>
  &nbsp; <br>
  &nbsp;&nbsp;&nbsp; 9.2动态查找算法（树表的查找） <br>
  &nbsp;&nbsp;&nbsp; 9.2.1二叉排序树和平衡二叉树 <br>
        1、二叉查找树（二叉排序树）及其查找过程 <br>
        2、二叉排序树的查找 <br>
        3、二叉排序树的插入算法（递归算法） <br>
        int&nbsp;InsertBST(BSTNode&nbsp;*&amp;p,KeyType&nbsp;k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;if&nbsp;(p==NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//原树为空,新插入的记录为根结点&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p=(BSTNode*)malloc(sizeof(BSTNode));&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;key=k;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;lchild=p-&gt;rchild=NULL;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(k==p-&gt;key)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//树中存在相同关键字的结点,返回0&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(k&lt;p-&gt;key)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnInsertBST(p-&gt;lchild,k);&nbsp;&nbsp;//插入到*p的左子树中&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnInsertBST(p-&gt;rchild,k);&nbsp;&nbsp;//插入到*p的右子树中&nbsp;&nbsp;<br>
        }&nbsp;&nbsp;</p>
      <p>4、二叉排序树的生成算法 <br>
        BSTNode&nbsp;*CreateBST(KeyType&nbsp;A[],int&nbsp;n)&nbsp;&nbsp;&nbsp;//返回BST树根结点指针&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;BSTNode*bt=NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始时bt为空树&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=0;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;while(i&lt;n)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InsertBST(bt,A[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将关键字A[i]插入二叉排序树T中&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;returnbt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//返回建立的二叉排序树的根指针&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
      }&nbsp;&nbsp;</p>
      <p>5、二叉排序树的查找算法（递归） <br>
        BSTNode&nbsp;*SearchBST(BSTNode&nbsp;*bt,KeyType&nbsp;k)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
        {&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bt==NULL||&nbsp;bt-&gt;key==k)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//递归终结条件&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnbt;&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;if(k&lt;bt-&gt;key)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnSearchBST(bt-&gt;lchild,k);&nbsp;&nbsp;//在左子树中递归查找&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SearchBST(bt-&gt;rchild,k);&nbsp;&nbsp;//在右子树中递归查找&nbsp;&nbsp;<br>
  &nbsp;&nbsp;<br>
      }&nbsp;&nbsp;</p>
      <p>&nbsp;&nbsp;&nbsp; 9.3&nbsp;哈希表 <br>
        1、确定的对应关系f<br>
        2、对应关系f就是哈希函数 <br>
        3、哈希函数是一个映象，构造哈希函数的方法： <br>
        直接定址法、除留余数法、数字分析法、平方取中法、折叠法 <br>
        4、冲突现象和解决冲突的方法 <br>
        当k1!=k2时，f(k1)=f(k2)<br>
        开放定址法 <br>
        （1）线性探测法 <br>
        （2）平方探测法 <br>
        拉链法 </p>
      <p>&nbsp;</p>
<div id="footer">
    <p>All Copyright Reserved 2015/2-2017/7 by jtahstu </p>
    </div>
  </div>
</body>
</html>
